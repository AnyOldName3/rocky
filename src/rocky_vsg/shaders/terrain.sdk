// Utility functions that should work in any stage

layout(set = 0, binding = 10) uniform sampler2D elevation_tex;

layout(set = 0, binding = 13) uniform TileData
{
    mat4 elevation_matrix;
    mat4 color_matrix;
    mat4 normal_matrix;
    vec2 elevTexelCoeff;
} tile;

const float elev_tile_size = 257;
const float elev_tile_bias = 0.5;
const vec2 elev_tile_coeff = vec2(
    (elev_tile_size - (2.0*elev_tile_bias)) / elev_tile_size,
    elev_tile_bias / elev_tile_size);

// Sample the elevation data at a UV tile coordinate
float terrain_get_elevation(in vec2 uv)
{
    // Texel-level scale and bias allow us to sample the elevation texture
    // on texel center instead of edge.
    vec2 elevc = uv
        * elev_tile_coeff.x * tile.elevation_matrix[0][0]     // scale
        + elev_tile_coeff.x * tile.elevation_matrix[3].st     // bias
        + elev_tile_coeff.y;

    return texture(elevation_tex, elevc).r;
}

#if 0
// Read the normal vector and curvature at resolved UV tile coordinates
vec4 terrain_get_normal_and_curvature_scaled(in vec2 uv_scaledBiased)
{
    vec4 n = texture(normal_tex, uv_scaledBiased);
    n.xyz = n.xyz*2.0-1.0;
    float curv = n.z;
    n.z = 1.0 - abs(n.x) - abs(n.y);
    // unnecessary since Z is never < 0:
    //float t = clamp(-n.z, 0, 1);
    //n.x += (n.x > 0)? -t : t;
    //n.y += (n.y > 0)? -t : t;
    return vec4(normalize(n.xyz), curv);
}

vec4 terrain_get_normal_and_curvature(in vec2 st)
{
    vec2 uv_scaledBiased = st
        * elev_tile_coeff.x * tile.elevation_matrix[0][0]
        + elev_tile_coeff.x * tile.elevation_matrix[3].st
        + elev_tile_coeff.y;

    return terrain_get_normal_and_curvature_scaled(uv_scaledBiased);
}
#endif